<lib>
  <bs-container :size="md" style="padding: 0">
  <bs-row :class-sample-points="[[true]]">
  <bs-col :size="md">
    <bs-card style="height: 100%">
    <ul class="sample">
    <li>
      A <code>count</code> value is added to the <code>&lt;div></code> and
      initialized to zero. It's declared with a <code>:</code>-prefixed
      attribute, and initialized with a <code>[['[[']]...[[']'+']']]</code>
      JavaScript expression.
    </li>
    <li>
      A <code>did-init</code> delegate expression runs
      after the <code>&lt;div></code> is initialized
      and starts a timer to increment <code>count</code> every second.
    </li>
    <li style="margin-bottom: 0;">
      A <code>[['[[']]count[[']'+']']]</code> expression is used
      to reflect the current value of <code>count</code>
      &mdash; thanks to reactivity, the DOM is automatically updated
      whenever <code>count</code> changes.
    </li>
    </ul>
    </bs-card>
  </bs-col>
  <bs-col :size="md">
    <bs-card style="height: 100%">
      <div class="sample-note">
        <span><bs-icon :icon="hand-index" style="transform: rotate(90deg); display: inline-block;"/></span>
        <span>By default, logic runs in both the server and the client</span>
      </div>
      <ul class="sample">
      <li>
        Page logic starts in the server and continues in the client.
      </li>
      <li>
        The server
        initializes <code>count</code> and reflects it in the text,
        but <code>setInterval()</code> does nothing as 
        future action is left to the client.
      </li>
      <li style="margin-bottom: 0;">
        The client finds <code>count</code>
        already initialized and reflected in page text,
        and its <code>setInterval()</code>
        call starts an actual timer that keeps the count going.
      </li>
      </ul>
    </bs-card>
  </bs-col>
  </bs-row>
  </bs-container>
</lib>